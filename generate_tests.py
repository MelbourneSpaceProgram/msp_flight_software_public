import re
import glob
from subprocess import call
import os
import argparse
from pathlib import Path, PurePosixPath


def find_all_test_files(directory_root="./"):
    """ Finds all file paths that define a set of unit tests.
    This is defined as any .cpp file that is found within a directory
    called 'tests'. Do not name any other directory test."""

    # directory_root should not start with a /, but it should end with one
    return glob.glob(directory_root + "src/**/tests/*", recursive=True)


def generate_test_runner_definition(test_file_path):
    """ Generates all information needed to produce a test
    runner for the given test implementation file."""

    filename_wo_extension = test_file_path.stem

    test_runner_definition = {
        "main_name": "{}_runner".format(filename_wo_extension),
        "header_file": "test_runners/{}.h".format(filename_wo_extension),
        # PurePosixPath ensures we are consistent in our path formatting across all platforms
        "input_test_file": "{}".format(PurePosixPath(test_file_path)),
        "output_runner_file": "test_runners/{}_runner.cpp".format(filename_wo_extension)
    }

    return test_runner_definition


def exec_args_from_test_runner_definition(definition):
    exec_args = []
    exec_args.append('ruby')
    exec_args.append('auto/generate_test_runner.rb')
    exec_args.append('auto/generate_runner_config.yml')
    exec_args.append('--main_name={main_name}'.format(**definition))
    exec_args.append('--header_file={header_file}'.format(**definition))
    exec_args.append('{input_test_file}'.format(**definition))
    exec_args.append('{output_runner_file}'.format(**definition))

    return exec_args


def write_master_runner_header(definitions, location="./test_runners/master_runner.h"):
    with open(location, 'w') as f:
        f.write("/* AUTOGENERATED FILE. DO NOT EDIT. */\n\n")
        f.write("#ifndef TEST_RUNNERS_MASTER_RUNNER_H_\n")
        f.write("#define TEST_RUNNERS_MASTER_RUNNER_H_\n\n")  

        f.write("void master_tests_thread();\n")

        for test_runner_definition in definitions:
            f.write("int {}();\n".format(test_runner_definition['main_name']))

        f.write("void SetUp();\n")
        f.write("void TearDown();\n\n")

        f.write("#endif  // TEST_RUNNERS_MASTER_RUNNER_H_\n")  

def write_master_runner_impl(definitions, location="./test_runners/master_runner.cpp"):
    with open(location, 'w') as f:
        f.write("/* AUTOGENERATED FILE. DO NOT EDIT. */\n\n")

        for test_runner_definition in definitions:
            f.write("#include <{}>\n".format(test_runner_definition['header_file']))

        f.write("#include <test_runners/master_runner.h>\n\n")

        f.write('static const char startMessage[] = "STARTING ON TARGET UNIT TESTS";\n')
        f.write('static const char endMessage[] = "FINISHED ON TARGET UNIT TESTS";\n')
        f.write('\n')

        # Now write the master runner function
        f.write("void master_tests_thread() {\n\n")

        f.write("    UNITY_PRINT_EOL();\n")
        f.write("    UnityPrint(startMessage);\n")
        f.write("    UNITY_PRINT_EOL();\n\n")

        for test_runner_definition in definitions:
            f.write("    {}();\n".format(test_runner_definition['main_name']))

        f.write("\n")
        f.write("    UNITY_PRINT_EOL();\n")
        f.write("    UnityPrint(endMessage);\n")
        f.write("    UNITY_PRINT_EOL();\n")

        f.write("}\n")

        f.write("\n\n")

        f.write("void SetUp() {}\n")
        f.write("void TearDown() {}\n")


def clean_test_runners_directory():
    """ Removes all automatically generated test files, except for the Unity test framework
    from the test_runners/ directory. """

    for file_name in glob.glob('test_runners/*.*'):
        if not Path(file_name).stem.startswith('unity'):
            os.remove(file_name)

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("--debug_mode", help="Prints debug information")
    parser.add_argument("--root_directory", help="Sets the working directory of the script")
    args = parser.parse_args()
    clean_test_runners_directory()

    root_directory = args.root_directory
    debug_mode = args.debug_mode

    if root_directory:
        working_dir = Path(root_directory).resolve()
        os.chdir(str(working_dir))
        if debug_mode:
            print("Changing root directory to: {}".format(root_directory))

    if debug_mode:
        print("Directory at script execution: {}".format(os.getcwd()))

    print("This will delete all automatically generated files in")
    print("the test_runners/ directory. Please confirm you have")
    print("not manually created any files here.")
    response = input("Confirm (y/N): ")

    if not (response == 'y' or response == 'Y'):
        print("Aborting test generator")
        exit()

    test_runner_definitions = []
    for test_file_path_string in find_all_test_files():
        test_file_path = Path(test_file_path_string)
        definition = generate_test_runner_definition(test_file_path)
        test_runner_definitions.append(definition)

        # Generate the execution command for the Ruby script
        exec_args = exec_args_from_test_runner_definition(definition)

        if debug_mode:
            # Check if our input and outputs exist
            print("="*80)
            print(" "*10 + " Debug Information for {}".format(definition['main_name']))
            print("="*80)

            generator_path = Path("auto/generate_test_runner.rb")
            header_file_path = Path(definition['header_file'])
            input_test_file_path = Path(definition['input_test_file'])
            output_runner_file_path = Path(definition['output_runner_file'])

            print("File {} exists: {}".format(generator_path, generator_path.exists()))
            print("File {} exists: {}".format(header_file_path, header_file_path.exists()))
            print("File {} exists: {}".format(input_test_file_path, input_test_file_path.exists()))
            print("File {} exists: {}".format(output_runner_file_path, output_runner_file_path.exists()))
            print("Command to execute: {}".format(exec_args))

        call(exec_args)
        print("Wrote runner for: {}".format(definition['input_test_file']))

    write_master_runner_impl(test_runner_definitions)
    write_master_runner_header(test_runner_definitions)
